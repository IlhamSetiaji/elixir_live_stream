<div class="container-fluid vh-100 p-0 bg-dark" id="video-app" phx-hook="WebRTCVideo" data-room-id={@room_id} data-auto-start="false">
  <!-- Room ID Display -->
  <div class="room-id-display">
    <i class="fas fa-id-card me-2"></i>
    Room: <%= @room_id %>
  </div>
  
  <!-- Connection Status -->
  <div class="connection-status status-disconnected">
    Disconnected
  </div>
  
  <!-- Main Video Container -->
  <div class="position-relative w-100 h-100">
    <!-- Remote Video (Main) -->
    <video 
      id="remoteVideo"
      class="video-element w-100 h-100"
      autoplay
      playsinline
      muted
      style="background: #000; object-fit: cover;"
    ></video>
    
    <!-- Local Video (Picture-in-Picture) -->
    <video 
      id="localVideo"
      class="local-video draggable-video"
      autoplay
      playsinline
      muted
      style="background: #333; cursor: pointer;"
      onclick="swapVideos()"
      title="Click to swap videos"
    ></video>
    
    <!-- Loading State -->
    <div class="position-absolute top-50 start-50 translate-middle text-white text-center" id="loading-state">
      <div class="loading-spinner mb-3"></div>
      <h4>Setting up your video...</h4>
      <p class="text-muted">Please allow camera and microphone access</p>
    </div>
    
    <!-- Waiting for Callee -->
    <div class="position-absolute top-50 start-50 translate-middle text-white text-center d-none" id="waiting-state">
      <i class="fas fa-clock fa-3x mb-3 text-info"></i>
      <h4>Waiting for someone to join...</h4>
      <p class="text-muted">Share this room ID: <strong><%= @room_id %></strong></p>
      <div class="mt-3">
        <button class="btn btn-outline-light" onclick="copyRoomId()">
          <i class="fas fa-copy me-2"></i>
          Copy Room ID
        </button>
      </div>
    </div>
    
    <!-- Participants List -->
    <div class="position-absolute top-0 end-0 m-3" id="participants-panel">
      <div class="card bg-dark text-white" style="min-width: 250px; opacity: 0.9;">
        <div class="card-header py-2">
          <h6 class="mb-0">
            <i class="fas fa-users me-2"></i>
            Participants (<span id="participant-count">1</span>)
          </h6>
        </div>
        <div class="card-body py-2">
          <div id="participants-list">
            <div class="participant-item d-flex align-items-center mb-1">
              <i class="fas fa-user-circle me-2 text-primary"></i>
              <span>You (Host)</span>
              <i class="fas fa-crown ms-auto text-warning" title="Host"></i>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Control Panel -->
  <div class="controls-panel">
    <button id="muteBtn" class="control-btn btn-mute" title="Toggle Microphone">
      <i class="fas fa-microphone"></i>
    </button>
    
    <button id="cameraBtn" class="control-btn btn-camera" title="Toggle Camera">
      <i class="fas fa-video"></i>
    </button>
    
    <button id="callBtn" class="control-btn btn-call" title="Start Call">
      <i class="fas fa-phone"></i>
    </button>
    
    <button id="hangupBtn" class="control-btn btn-hangup" title="End Call">
      <i class="fas fa-phone-slash"></i>
    </button>
    
    <button class="control-btn btn-secondary" onclick="leaveRoom()" title="Leave Room">
      <i class="fas fa-sign-out-alt"></i>
    </button>
  </div>
</div>

<script>
  function copyRoomId() {
    const roomId = '<%= @room_id %>';
    const btn = event.target.closest('button');
    
    // Try the modern clipboard API first
    if (navigator.clipboard && window.isSecureContext) {
      navigator.clipboard.writeText(roomId).then(() => {
        showCopySuccess(btn);
      }).catch(() => {
        fallbackCopyToClipboard(roomId, btn);
      });
    } else {
      fallbackCopyToClipboard(roomId, btn);
    }
  }
  
  function fallbackCopyToClipboard(text, btn) {
    // Create a temporary textarea element
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        showCopySuccess(btn);
      } else {
        showCopyError(text);
      }
    } catch (err) {
      showCopyError(text);
    } finally {
      document.body.removeChild(textArea);
    }
  }
  
  function showCopySuccess(btn) {
    const originalText = btn.innerHTML;
    btn.innerHTML = '<i class="fas fa-check me-2"></i>Copied!';
    btn.classList.remove('btn-outline-light');
    btn.classList.add('btn-success');
    
    setTimeout(() => {
      btn.innerHTML = originalText;
      btn.classList.remove('btn-success');
      btn.classList.add('btn-outline-light');
    }, 2000);
  }
  
  function showCopyError(roomId) {
    // Show a modal or prompt with the room ID for manual copying
    const message = `Please copy this room ID manually: ${roomId}`;
    prompt(message, roomId);
  }
  
  function leaveRoom() {
    if (confirm('Are you sure you want to leave the room?')) {
      window.location.href = '/';
    }
  }
  
  function swapVideos() {
    // Only allow swapping if not currently dragging
    const isDragging = window.isDragging || false;
    if (isDragging) return;
    
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    
    // Get current streams
    const localStream = localVideo.srcObject;
    const remoteStream = remoteVideo.srcObject;
    
    // Swap streams if both exist
    if (localStream && remoteStream) {
      // Store current transform position
      const currentTransform = localVideo.style.transform;
      
      // Swap the streams
      localVideo.srcObject = remoteStream;
      remoteVideo.srcObject = localStream;
      
      // Maintain the position of the PiP video
      setTimeout(() => {
        localVideo.style.transform = currentTransform;
      }, 10);
      
      // Add visual feedback
      localVideo.style.borderColor = 'rgba(0, 255, 0, 0.8)';
      setTimeout(() => {
        localVideo.style.borderColor = 'rgba(255, 255, 255, 0.8)';
      }, 300);
    }
  }
  
  function addParticipant(userId, userName = null, isHost = false) {
    const participantsList = document.getElementById('participants-list');
    const participantCount = document.getElementById('participant-count');
    
    // Check if participant already exists
    if (document.getElementById(`participant-${userId}`)) {
      return;
    }
    
    const displayName = userName || (isHost ? 'You (Host)' : 'Participant');
    
    const participantDiv = document.createElement('div');
    participantDiv.id = `participant-${userId}`;
    participantDiv.className = 'participant-item d-flex align-items-center mb-1';
    participantDiv.innerHTML = `
      <i class="fas fa-user-circle me-2 text-${isHost ? 'primary' : 'info'}"></i>
      <span class="flex-grow-1" style="min-width: 0; overflow: hidden; text-overflow: ellipsis;">${displayName}</span>
      ${isHost ? '<i class="fas fa-crown ms-auto text-warning" title="Host"></i>' : '<i class="fas fa-circle ms-auto text-success" title="Online"></i>'}
    `;
    
    if (isHost) {
      participantsList.insertBefore(participantDiv, participantsList.firstChild);
    } else {
      participantsList.appendChild(participantDiv);
    }
    
    // Update participant count
    const currentCount = participantsList.children.length;
    participantCount.textContent = currentCount;
  }
  
  function removeParticipant(userId) {
    const participantElement = document.getElementById(`participant-${userId}`);
    if (participantElement) {
      participantElement.remove();
      
      // Update participant count
      const participantsList = document.getElementById('participants-list');
      const participantCount = document.getElementById('participant-count');
      participantCount.textContent = participantsList.children.length;
    }
  }
  
  // Show/hide loading and waiting states
  document.addEventListener('DOMContentLoaded', () => {
    const loadingState = document.getElementById('loading-state');
    const waitingState = document.getElementById('waiting-state');
    
    // Initialize draggable video
    initializeDraggableVideo();
    
    // Update participant list with user's name
    updateHostParticipantName();
    
    // Start with loading state, then show waiting state
    setTimeout(() => {
      loadingState.style.display = 'none';
      waitingState.classList.remove('d-none');
    }, 2000);
    
    // Listen for peer joined events via custom events
    window.addEventListener('peer-joined', (event) => {
      console.log('Peer joined event received in caller page:', event.detail);
      
      // Hide ALL other states first
      hideAllStates();
      
      // Show a "ready to call" message
      showReadyToCallState();
      
      // Add participant to the list
      if (event.detail && event.detail.user_id) {
        addParticipant(event.detail.user_id, event.detail.user_name, false);
      }
    });
    
    // Listen for call started events
    window.addEventListener('call-started', () => {
      console.log('Call started, hiding all states');
      hideAllStates();
    });
    
    // Listen for peer left events
    window.addEventListener('peer-left', (event) => {
      console.log('Peer left event received:', event.detail);
      if (event.detail && event.detail.user_id) {
        removeParticipant(event.detail.user_id);
        
        // Check if we're back to waiting state (no other participants)
        const participantsList = document.getElementById('participants-list');
        const nonHostParticipants = Array.from(participantsList.children).filter(child => 
          !child.textContent.includes('You (Host)')
        );
        
        if (nonHostParticipants.length === 0) {
          hideAllStates();
          waitingState.classList.remove('d-none');
        }
      }
    });
  });
  
  function updateHostParticipantName() {
    const userName = sessionStorage.getItem('userName');
    if (userName) {
      const hostElement = document.querySelector('#participants-list .participant-item span');
      if (hostElement) {
        hostElement.textContent = `${userName} (Host)`;
      }
    }
  }
  
  function initializeDraggableVideo() {
    const localVideo = document.getElementById('localVideo');
    let isDragging = false;
    let hasMoved = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    
    // Make isDragging globally accessible
    Object.defineProperty(window, 'isDragging', {
      get: () => hasMoved,
      set: (value) => hasMoved = value
    });
    
    // Set initial position (bottom-right corner)
    const container = localVideo.parentElement;
    
    function updatePosition() {
      const containerRect = container.getBoundingClientRect();
      xOffset = containerRect.width - 220; // 200px width + 20px margin
      yOffset = containerRect.height - 170; // 150px height + 20px margin
      setTranslate(xOffset, yOffset, localVideo);
    }
    
    // Set initial position
    updatePosition();
    
    // Update position on window resize
    window.addEventListener('resize', updatePosition);
    
    localVideo.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
    
    // Touch events for mobile
    localVideo.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', dragMove);
    document.addEventListener('touchend', dragEnd);
    
    function dragStart(e) {
      hasMoved = false;
      
      if (e.type === 'touchstart') {
        initialX = e.touches[0].clientX - xOffset;
        initialY = e.touches[0].clientY - yOffset;
      } else {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
      }
      
      if (e.target === localVideo) {
        isDragging = true;
        localVideo.style.cursor = 'grabbing';
      }
    }
    
    function dragMove(e) {
      if (isDragging) {
        e.preventDefault();
        hasMoved = true;
        
        if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        } else {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        }
        
        // Get container bounds
        const containerRect = container.getBoundingClientRect();
        const videoWidth = 200;
        const videoHeight = 150;
        
        // Constrain to container bounds
        const maxX = containerRect.width - videoWidth;
        const maxY = containerRect.height - videoHeight;
        
        currentX = Math.max(0, Math.min(currentX, maxX));
        currentY = Math.max(0, Math.min(currentY, maxY));
        
        xOffset = currentX;
        yOffset = currentY;
        
        setTranslate(currentX, currentY, localVideo);
      }
    }
    
    function dragEnd(e) {
      if (isDragging) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
        localVideo.style.cursor = 'grab';
        
        // Prevent click event if the video was dragged
        if (hasMoved) {
          setTimeout(() => {
            hasMoved = false;
          }, 100);
        }
      }
    }
    
    function setTranslate(xPos, yPos, el) {
      el.style.transform = `translate(${xPos}px, ${yPos}px)`;
    }
    
    // Set initial cursor
    localVideo.style.cursor = 'grab';
  }
  
  function hideAllStates() {
    const loadingState = document.getElementById('loading-state');
    const waitingState = document.getElementById('waiting-state');
    const readyMessage = document.getElementById('ready-message');
    
    if (loadingState) loadingState.style.display = 'none';
    if (waitingState) waitingState.classList.add('d-none');
    if (readyMessage) readyMessage.remove();
  }
  
  function showReadyToCallState() {
    const videoContainer = document.querySelector('.position-relative.w-100.h-100');
    const readyMessage = document.createElement('div');
    readyMessage.id = 'ready-message';
    readyMessage.className = 'position-absolute top-50 start-50 translate-middle text-white text-center';
    readyMessage.innerHTML = `
      <i class="fas fa-phone fa-3x mb-3 text-success"></i>
      <h4>Ready to start the call!</h4>
      <p class="text-muted">Click the green phone button to start the video call</p>
    `;
    videoContainer.appendChild(readyMessage);
  }
</script>

<style>
  #video-app {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  
  .video-element {
    background: linear-gradient(45deg, #1a1a1a, #2d2d2d);
  }
  
  .local-video {
    width: 200px;
    height: 150px;
    border: 3px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    position: absolute !important;
    top: auto !important;
    right: auto !important;
    bottom: auto !important;
    left: auto !important;
    z-index: 1000;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    border-radius: 8px;
    transition: border-color 0.3s ease;
  }
  
  .local-video.draggable-video {
    cursor: grab;
    transition: transform 0.1s ease-out, border-color 0.3s ease;
  }
  
  .local-video.draggable-video:active {
    cursor: grabbing;
  }
  
  .local-video:hover {
    border-color: rgba(255, 255, 255, 1);
    box-shadow: 0 4px 25px rgba(0, 0, 0, 0.7);
  }
  
  .controls-panel {
    backdrop-filter: blur(10px);
    background-color: rgba(0, 0, 0, 0.7);
  }
  
  .control-btn {
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
  }
  
  .control-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  }
  
  .room-id-display {
    font-size: 14px;
    letter-spacing: 1px;
    background-color: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
  }
  
  .connection-status {
    font-size: 14px;
    font-weight: 600;
    backdrop-filter: blur(10px);
  }
</style>
